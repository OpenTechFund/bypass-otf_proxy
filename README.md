# Overview

This repository contains 4 applications:

- An application to set up, maintain, and report on mirrors and onions.
- An application to renew ECS mirrors
- An application to report on logfiles generated by [EOTK](https://github.com/alecmuffett/eotk) (the onion proxy)
- A Flask application (still in progress) which serves as a reporting API for the Bypass Censorship Extension, as well as a front-end for viewing:
  - Reports from that API
  - Current mirrors/onions and their status
  - EOTK log file reporting

# System

All of this has been tested on Ubuntu 18.04 LTS. It should work on any Ubuntu/Debian based system. It has not been tested on Mac OS or Windows.

# Prerequisites

You need: 

- a server to host this
- an AWS account that has permission to create Cloudfront Distributions and ECS containers/services
- a Fastly account that has permission to create new configurations
- an Azure account with permissions to create new CDN distributions
- a Github repo for mirrors in JSON format that is read by the [Bypass Censorship Extension](https://github.com/OpenTechFund/bypass-censorship-extension) browser extension. An example [is here](https://github.com/OpenTechFund/bypass-mirrors)

If you want to add onions, the best method is using Alec Muffett's [EOTK (Enterprise Onion ToolKit)](https://github.com/alecmuffett/eotk). One way to mine vanity .onion addresses is to use [eschalot](https://github.com/ReclaimYourPrivacy/eschalot). At this time, onion addition is not automated.

# Setup 

```
git clone https://github.com/OpenTechFund/bypass-otf_proxy
cd bcapp
pipenv install
pipenv shell
```

# Mirror Application

## Usage
```
Usage: python automation.py [OPTIONS]

Options:
  --testing [onions|noonions|domains]
                                  Domain testing of available mirrors - choose
                                  onions, noonions, or domains
  --domain TEXT                   Domain to act on
  --proxy TEXT                    Proxy server to use for testing/domain
                                  detail.
  --existing TEXT                 Mirror exists already, just add to github.
  --replace TEXT                  Mirror/onion to replace.
  --delete                        Delete a domain from list
  --remove TEXT                   Mirror or onion to remove
  --domain_list                   List all domains and mirrors/onions
  --mirror_list                   List mirrors for domain
  --mirror_type [cloudfront|azure|ecs|fastly|onion]
                                  Type of mirror
  --nogithub                      Do not add to github
  --report                        Get report from api database
  --mode [daemon|web|console]     Mode: daemon, web, console
  --help                          Show this message and exit.
```

## Listing

To get a list of all domains and mirrors use:
`python automation.py --domain_list`

To get a list of one domain and it's mirrors (and test each) use:
`python automation.py --domain=domain.com`

## Testing:

`python automation.py --testing=domains|onions|noonions`

The 'domains' option just tests the actual domains from whereever you are sitting. So if you are behind a potential block, you'll be able to see whether or not you can reach those domains.

The 'noonions' option will cycle through each domain in the mirror json file, and test for response codes for the standard http/https mirrors. It will determine the number of domains with errors, and return which ones have errors. It will also return any domains without a usable mirror.

The 'onions' option will do the same with onions. Tor has to be installed properly to test these.

## Domain addition: 

To add an existing mirror (one that you have already set up, including onions) use:

`python automation.py --domain=domain.com --existing=domain_mirror.com`

This will add a mirror (or onion, if it is a .onion) to the json file. If the domain doesn't exist in the json file, it will add the domain.

To add a new mirror, for Cloudfront, Fastly, Azure or ECS use:

`python automation.py --domain=domain.com --mirror_type=cloudfront|fastly|azure|ecs|onion`

(The cloudfront, fastly, azure and ecs processes are automated. The onion process is not.)

If you want a cloudfront distro, it will create that for you, and tell you the domain. For Fastly and Azure, you'll have to specify the Fastly and Azure subdomain (Cloudfront specifies a subdomain for you, Fastly and Azure require you to define it.)

All configurations are in auto.cfg (see auto.cfg-example)

## Mirror replacement

To replace one mirror with another use:

`python automation.py --domain=domain.com --replace=oldmirror.com --existing=newmirror.com`

or
*(implemented for ecs and cloudfront so far)*

`python automation.py --domain=domain.com --replace=oldmirror.com --mirror_type=ecs|cloudfront|fastly|azure`

If the mirror_type is defined, the replacement will be automated, and whatever is needed to reset the mirror url will be done. 

## Domain Deletion

To delete an entire domain and it's mirrors/onions, use:

`python automation.py --domain=domain.com --delete`

## Mode

Daemon mode is for things like cron jobs - 

## Notes

There are some defaults for all four systems, and if you want to change those, you would need to go to the documentation for each and modify the code:

* [Cloudfront](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudfront.html#CloudFront.Client.create_distribution)
* [Fastly](https://docs.fastly.com/api/config) and [Fastly-Python](https://github.com/maxpearl/fastly-py)
* [Azure](https://docs.microsoft.com/en-us/python/api/overview/azure/cdn?view=azure-python)

Problems you might encounter:

- IP address of mirror source (Cloudfront, Fastly, etc.) blocked by origin website by policy
- Assets (css, video etc.) not completely mirrored properly, leading to bad formatting or missing content
- Mirrors (ECS mirrors in particular) becoming outdated quickly
- Other mirroring difficulties that are hard to diagnose (for example, some  websites proxy fine with one service but not another.)

# Mirror Renewing Application

Because ECS mirrors (which are actual mirrors of content) become stale quicky, there's a small app to renew them. You can create a script like:

```
#/bin/sh
/path/to/virtualenvs/virtualenv/bin/python /path/to/bypass-otf_proxy/bcapp/mirror_renew.py >> /path/to/log/storage/mr.log
```
Add this to your crontab.

This app looks at all mirrors, finds all with IP addresses (ECS mirrors only have IP addresses) checks all ECS services for those IP addresses, and for any that match, it restarts that service (thus changing the IP address and re-doing the mirror.) It then saves the new IP in the github repo.

# Log Reporting Analysis Application

## Usage

```
Usage: python log_stats.py [OPTIONS]

Options:
  --percent INTEGER    Floor percentage to display for agents and codes
                       (default is 5%)
  --num INTEGER        Top number of pages to display (default is 10)
  --recursive          Descent through directories
  --unzip              Unzip and analyze zipped log files (bz2 files only)
  --daemon             Run in daemon mode. Suppresses all output.
  --skipsave           Skip saving log file to S3
  --paths_ignore TEXT  Comma delimited list (no spaces) of paths to ignore for
                       log analysis.
  --help               Show this message and exit.
```

The [configuration file](bcapp/auto.cfg-example) contains two important variables under the 'LOGS' directive: 

```
[LOGS]
path_file = /path/to/logpaths.txt
log_storage_bucket = s3_bucket_to_store_logs
```

The path_file is the location of the file which contains the paths for where to find the EOT logs. The format of this file should look something like:

```
domain1.org:/path/to/eotk/projects.d/domain1.d/log.d
domain2.org:/path/to/eotk/projects.d/domain2.d/log.d
domain3.com:/path/to/eotk/projects.d/domain3.d/log.d
```

ETOK stores the files in projects.d under each project. You'll almost certainly want to use the --recursive option

Log files and analysis goes to S3 in the bucket specified in "log_storage_bucket" in the configuration file. The --skipsave option will skip saving the log files to S3 (the analysis files will still be saved.) You can run this in daemon mode, which suppresses all output. This is great for periodic cron jobs.

The paths_ignore option is for the analysis of pages visited. The code eliminates most assets from reporting (currently, .css, .js, .jpg, .jpeg, .gif, .woff, .woff2, .svg, .ttf, and favicon.ico.) The paths_ignore allows you to ignore complete paths, like /ad, for example. Do not include spaces in this list.

# Flask Application (work in progress)

## Installation/setup

You'll need to set up a postgresql database, which the flask app has permission to access.

Use the .env_example to create an .env file.

To start up the app, make sure you've started the virtual environment.

```
cd bcapp\api
source .env
```

The first time you run the app, set up the database:

```
flask db init
flask db migrate
flask db upgrade
```

Then run the app:

`flask run`

(or `flask run &` if you want it to run in the background.)

It will be running on port 5000. This is for development purposes only.

## Bypass Censorship API

The API uses auth tokens just to protect from spurious/malicious reporting. You'll likely want to do this to the database before you run the app:

`INSERT INTO auth_tokens (id, auth_token) VALUES ('1','some auth token here')`

Then you'll add that auth_token to the json request to the API.

This api (bcapp/api) can take reports from the Bypass Censorship Browser extension (and eventually interface with proxies and mirrors.) This is currently a work in progress.

The file bcapp/api/json_request.json is the format for the json request to the API. 

The URL for reporting is: http://host:5000/api/v1/report (development purposes)

## Mirrors/Onions status reporting


## EOTK log file reporting
 
